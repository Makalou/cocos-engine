// Copyright (c) 2017-2020 Xiamen Yaji Software Co., Ltd.

CCEffect %{
  techniques:
  - name: opaque
    passes:
    - vert: ray-query-vs
      frag: ray-query-fs
      properties: &props
        tilingOffset:         { value: [1.0, 1.0, 0.0, 0.0] }
        mainColor:            { value: [1.0, 1.0, 1.0, 1.0], target: albedo, linear: true, editor: { displayName: Albedo, type: color } }
        albedoScale:          { value: [1.0, 1.0, 1.0], target: albedoScaleAndCutoff.xyz }
        alphaThreshold:       { value: 0.5, target: albedoScaleAndCutoff.w, editor: { parent: USE_ALPHA_TEST, slide: true, range: [0, 1.0], step: 0.001 } }
        occlusion:            { value: 1.0, target: pbrParams.x, editor: { slide: true, range: [0, 1.0], step: 0.001 } }
        roughness:            { value: 0.8, target: pbrParams.y, editor: { slide: true, range: [0, 1.0], step: 0.001 } }
        metallic:             { value: 0.6, target: pbrParams.z, editor: { slide: true, range: [0, 1.0], step: 0.001 } }
        specularIntensity:    { value: 0.5, target: pbrParams.w, editor: { slide: true, range: [0.0, 1.0], step: 0.001 } }
        emissive:             { value: [0.0, 0.0, 0.0, 1.0], linear: true, editor: { type: color } }
        emissiveScale:        { value: [1.0, 1.0, 1.0], target: emissiveScaleParam.xyz }
        normalStrength:       { value: 1.0, target: emissiveScaleParam.w, editor: { parent: USE_NORMAL_MAP, slide: true, range: [0, 5.0], step: 0.001 } }
        mainTexture:          { value: grey, target: albedoMap, editor: { displayName: AlbedoMap } }
        normalMap:            { value: normal }
        pbrMap:               { value: grey }
        metallicRoughnessMap: { value: grey }
        occlusionMap:         { value: white }
        emissiveMap:          { value: grey }
    - &forward-add
      vert: ray-query-vs
      frag: ray-query-fs
      phase: forward-add
      propertyIndex: 0
      embeddedMacros: { CC_FORWARD_ADD: true }
      depthStencilState:
        depthFunc: equal
        depthTest: true
        depthWrite: false
      blendState:
        targets:
        - blend: true
          blendSrc: one
          blendDst: one
          blendSrcAlpha: zero
          blendDstAlpha: one
  - name: transparent
    passes:
    - vert: ray-query-vs
      frag: ray-query-fs
      embeddedMacros: { CC_FORCE_FORWARD_SHADING: true }
      depthStencilState:
        depthTest: true
        depthWrite: false
      blendState:
        targets:
        - blend: true
          blendSrc: src_alpha
          blendDst: one_minus_src_alpha
          blendDstAlpha: one_minus_src_alpha
      properties: *props
    - *forward-add
}%

CCProgram shared-ubos %{
  uniform Constants {
    vec4 tilingOffset;
    vec4 albedo;
    vec4 albedoScaleAndCutoff;
    vec4 pbrParams;
    vec4 emissive;
    vec4 emissiveScaleParam;
  };
}%

CCProgram ray-query-vs %{
  precision highp float;
  #include <legacy/input-standard>
  #include <builtin/uniforms/cc-global>
  #include <legacy/decode-base>
  #include <legacy/local-batch>
  #include <shared-ubos>
  #include <legacy/fog-vs>
  #include <legacy/shadow-map-vs>

  #if USE_VERTEX_COLOR
    in vec4 a_color;
    out lowp vec4 v_color;
  #endif

  out vec3 v_position;
  out mediump vec3 v_normal;
  out vec2 v_uv;
  #if HAS_SECOND_UV
    out mediump vec2 v_uv1;
  #endif

  #if CC_RECEIVE_SHADOW
    out mediump vec2 v_shadowBias;
  #endif

  #if USE_NORMAL_MAP
    out mediump vec4 v_tangent;
  #else 
    out mediump vec4 v_tangent;
  #endif

  #if HAS_SECOND_UV || CC_USE_LIGHTMAP
    in vec2 a_texCoord1;
  #endif

  #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD
    #include <legacy/lightingmap-vs>
  #endif

  void main () {
    StandardVertInput In;
    CCVertInput(In);

    mat4 matWorld, matWorldIT;
    CCGetWorldMatrixFull(matWorld, matWorldIT);

    vec4 pos = matWorld * In.position;

    v_position = pos.xyz;
    v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);

    #if CC_RECEIVE_SHADOW
      v_shadowBias = CCGetShadowBias();
    #endif

    #if USE_TWOSIDE
      vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);
      v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;
    #endif

    #if USE_NORMAL_MAP
      v_tangent.xyz = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);
      v_tangent.w = In.tangent.w;
    #else
      v_tangent.xyz = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);
      v_tangent.w = In.tangent.w;
    #endif

    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;
    #if SAMPLE_FROM_RT
      CC_HANDLE_RT_SAMPLE_FLIP(v_uv);
    #endif
    #if HAS_SECOND_UV
      v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;
      #if SAMPLE_FROM_RT
        CC_HANDLE_RT_SAMPLE_FLIP(v_uv1);
      #endif
    #endif

    #if USE_VERTEX_COLOR
      v_color = a_color;
    #endif

    CC_TRANSFER_FOG(pos);
    CC_TRANSFER_SHADOW(pos);

    #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD
      CCLightingMapCaclUV();
    #endif

    gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;
  }
}%

CCProgram ray-query-fs %{
  precision highp float;
  #include <builtin/uniforms/cc-global>
  #include <shared-ubos>
  #include <legacy/fog-fs>
  #include <legacy/standard-surface-entry>
  #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD
    #include <legacy/lightingmap-fs>
  #endif
  
  #if __VERSION__ >= 460
    #include <builtin/uniforms/cc-acceleration-structure>
  #endif

  in vec3 v_position;
  in vec2 v_uv;
  #if HAS_SECOND_UV 
    in mediump vec2 v_uv1;
  #endif
  in mediump vec3 v_normal;

  #if CC_RECEIVE_SHADOW
    in mediump vec2 v_shadowBias;
  #endif

  #if USE_VERTEX_COLOR
    in lowp vec4 v_color;
  #endif

  #if USE_ALBEDO_MAP
    uniform sampler2D albedoMap;
    #pragma define-meta ALBEDO_UV options([v_uv, v_uv1])
  #endif
  #if USE_NORMAL_MAP
    in mediump vec4 v_tangent;
    uniform sampler2D normalMap;
    #pragma define-meta NORMAL_UV options([v_uv, v_uv1])
  # else 
    in mediump vec4 v_tangent;
  #endif
  #pragma define-meta PBR_UV options([v_uv, v_uv1])
  #if USE_PBR_MAP
    uniform sampler2D pbrMap;
  #endif
  #if USE_METALLIC_ROUGHNESS_MAP
    uniform sampler2D metallicRoughnessMap;
  #endif
  #if USE_OCCLUSION_MAP
    uniform sampler2D occlusionMap;
  #endif
  #if USE_EMISSIVE_MAP
    uniform sampler2D emissiveMap;
    #pragma define-meta EMISSIVE_UV options([v_uv, v_uv1])
  #endif

  #pragma define OCCLUSION_CHANNEL          r
  #pragma define ROUGHNESS_CHANNEL          g
  #pragma define METALLIC_CHANNEL           b
  #pragma define SPECULAR_INTENSITY_CHANNEL a

  #if USE_ALPHA_TEST
    #pragma define-meta ALPHA_TEST_CHANNEL options([a, r])
  #endif

  #if __VERSION__ >= 460
  uint baseHash( uvec2 p )
  {
    p = 1103515245U*((p >> 1U)^(p.yx));
    uint h32 = 1103515245U*((p.x)^(p.y>>3U));
    return h32^(h32 >> 16);
  }

  float hash1(inout float seed)
  {
    uint n = baseHash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));
    return float(n)/float(0xffffffffU);
  }

  vec3 random_in_unit_hemisphere(float seed)
  {
    float u = hash1(seed);
    float v = hash1(seed);
    float theta = u*2.0*PI;
    float sinTheta = sin(theta);
    float cosTheta = cos(theta);
    float cosPhi = v;
    float sinPhi = sqrt(1.0 - cosPhi * cosPhi);
    float x = sinPhi*cosTheta;
    float y = sinPhi*sinTheta;
    float z = cosPhi;
    return vec3(x,y,z);
  }

  float sdfSphere(in vec3 p,vec3 center,float radius)
  {
    return length(p-center)-radius;
  }

  float sdfPlane(in vec3 p,vec3 normal,float d)
  {
    return dot(p,normal)+d;
  }

  float sdfSphereDisplace(vec3 p, vec3 center,float ra)
  {
    float displacement = sin(5.0 * p.x) * sin(5.0 * p.y) * sin(5.0 * p.z) * 0.25;
    return displacement + sdfSphere(p, center, ra);
  }

  float sdfSphereTwist(vec3 p, vec3 center,float ra)
  {
    const float k = 1.0*abs(cos(0.05*cc_time.w)); // or some other amount
    float c = cos(k*p.y);
    float s = sin(k*p.y);
    mat2  m = mat2(c,-s,s,c);
    vec3  q = vec3(m*p.xz,p.y);
    return sdfSphereDisplace(q,center,ra);
  }

  float sdfSmoothUnion(float d1, float d2, float k)
  {
    float h = clamp(0.5+0.5*(d2-d1)/k, 0.0, 1.0);
    return mix(d2, d1, h) - k*h*(1.0-h);
  }

  vec3 calculate_normal(vec3 p, vec3 center, float r)
  {
    const float h = 1e-6;
    const vec2 k = vec2(1,-1);
    return normalize( k.xyy*sdfSphereTwist(p + k.xyy*h,center,r ) + 
                      k.yyx*sdfSphereTwist(p + k.yyx*h,center,r ) + 
                      k.yxy*sdfSphereTwist(p + k.yxy*h,center,r ) + 
                      k.xxx*sdfSphereTwist(p + k.xxx*h,center,r ) );
  }

  bool raymarchingSphere(vec3 ro, vec3 rd,vec3 center,float r,float tMin,float tMax,out float t,out vec3 normal){
    t = 0.001;
    float tmax = 100.0;
    const float MIN_HIT_DIST = 1e-5;

    for(int i = 0; i < 64; i++){
      vec3 cur_pos = ro + t*rd;
      float dist = sdfSphereTwist(cur_pos,center,r);
      if(dist < MIN_HIT_DIST){
        normal = calculate_normal(cur_pos,center,r);
        return true;
      }
      if(t > tmax){
        return false;
      }
      t+= dist;
    }
    return false;
  }

  #endif

  void surf (out StandardSurface s) {
    vec4 baseColor = albedo;
    #if USE_VERTEX_COLOR
      baseColor.rgb *= SRGBToLinear(v_color.rgb); // use linear
      baseColor.a *= v_color.a;
    #endif
    #if USE_ALBEDO_MAP
      vec4 texColor = texture(albedoMap, ALBEDO_UV);
      texColor.rgb = SRGBToLinear(texColor.rgb);
      baseColor *= texColor;
    #endif
    s.albedo = baseColor;
    s.albedo.rgb *= albedoScaleAndCutoff.xyz;

    #if USE_ALPHA_TEST
      if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;
    #endif

    #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD
      vec4 lightColor = texture(cc_lightingMap, v_luv.xy);
      s.lightmap = lightColor.xyz * v_luv.z;
      s.lightmap_test = v_luv.z; /*lum*/
    #endif

    s.normal = v_normal;

    #if CC_RECEIVE_SHADOW
      s.shadowBias = v_shadowBias;
    #endif

    mat3 TBN;

    #if USE_NORMAL_MAP
      vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);
      vec3 bitangent = cross(v_normal, v_tangent.xyz) * v_tangent.w; // note the cross order
      s.normal =
        (nmmp.x * emissiveScaleParam.w) * normalize(v_tangent.xyz) +
        (nmmp.y * emissiveScaleParam.w) * normalize(bitangent) +
        nmmp.z * normalize(s.normal);
      
      TBN = mat3(normalize(v_tangent.xyz),normalize(bitangent), normalize(s.normal));
    #else 
      vec3 bitangent = cross(v_normal, v_tangent.xyz) * v_tangent.w; 
      TBN = mat3(normalize(v_tangent.xyz),normalize(bitangent), normalize(s.normal));
    #endif

    HIGHP_VALUE_TO_STRUCT_DEFINED(v_position, s.position);

    #if __VERSION__ >= 460
      vec3 origin = s.position;
      bool hitaabb = false;

      vec3 light_points[4] = {vec3(1.995,5.443,3.199),vec3(1.179,10.125,0.022),vec3(1.726,11.071,3.873),vec3(7.3,5.89,-0.865)};

      float shadowFactor = .0;
      
      int frame_id = int(mod(int(cc_time.z),4));

      rayQueryEXT rayQuery;
      rayQueryInitializeEXT(rayQuery, cc_topLevelAS, gl_RayFlagsOpaqueEXT,0xFF,cc_cameraPos.xyz,0.01,normalize(s.position-cc_cameraPos.xyz),1000.0);

      while(rayQueryProceedEXT(rayQuery)){
        if(rayQueryGetIntersectionTypeEXT(rayQuery,false) == gl_RayQueryCandidateIntersectionAABBEXT){
          vec3 hitPoint = rayQueryGetIntersectionObjectRayOriginEXT(rayQuery,false);
          vec3 hitDir = rayQueryGetIntersectionObjectRayDirectionEXT(rayQuery,false);
          
          float r = 5.0*abs(sin(0.1*cc_time.w));
          vec3 ce = vec3(0.0,0.0,0.0);
          float t;
          if(raymarchingSphere(hitPoint,hitDir,ce,r,0.0,100.0,t,s.normal)){
            s.albedo = vec4(0.5,0.5,0.5,1.0);
            //s.position = hitPoint + t*hitDir;
            rayQueryGenerateIntersectionEXT(rayQuery,t);
            rayQueryTerminateEXT(rayQuery);
            hitaabb = true;
          }
        }
      }

      if(!hitaabb){
        for(int i = 0; i < 4; ++i)
      {
        vec3 light_position = light_points[i];
        vec3 L = light_position-origin; 
        vec3 direction = normalize(L);
        float tMin = 0.1f;
        float tMax = length(L);

        //rayQueryEXT rayQuery;
        rayQueryInitializeEXT(rayQuery, cc_topLevelAS,gl_RayFlagsTerminateOnFirstHitEXT, 0xFF, origin, tMin, direction, tMax);

        while(rayQueryProceedEXT(rayQuery));
      
        if(rayQueryGetIntersectionTypeEXT(rayQuery, true) != gl_RayQueryCommittedIntersectionNoneEXT)
        {
            shadowFactor += 1.0;
        }
      }
      
      shadowFactor/= 4.0;

      //ao
      float seed  = baseHash(uvec2(cc_time.w*gl_FragCoord.xy));
      
      //rayQueryEXT rayQuery;
      float tMin = 0.1f;//todo How to choose adaptive tMin according to vertex normal?
      float tMax = 0.7f;
      vec3 direction;

      float ao = .0;
      const int AO_SAMPLE = 8;
      const ivec2 tile_offset[4] = {ivec2(0,0),ivec2(0,1),ivec2(1,0),ivec2(1,1)};
      
      if(mod(ivec2(gl_FragCoord.xy+tile_offset[frame_id]),2)==ivec2(0,0)){
        for(int i = 0;i<AO_SAMPLE;++i){
          seed = hash1(seed);
          direction = TBN*random_in_unit_hemisphere(seed);
          rayQueryInitializeEXT(rayQuery, cc_topLevelAS,gl_RayFlagsTerminateOnFirstHitEXT, 0xFF, origin, tMin, direction, tMax);
          while(rayQueryProceedEXT(rayQuery));
          if(rayQueryGetIntersectionTypeEXT(rayQuery, true) != gl_RayQueryCommittedIntersectionNoneEXT)
          {
            ao += 1.0;
          }
        }
      }
      
      ao /= float(AO_SAMPLE);

      s.albedo *= (1.0 - ao);
      s.albedo *= (1.0 - shadowFactor);
      }

    #endif

    vec4 pbr = pbrParams;
    #if USE_PBR_MAP
      vec4 res = texture(pbrMap, PBR_UV);
      pbr.x *= res.OCCLUSION_CHANNEL;
      pbr.y *= res.ROUGHNESS_CHANNEL;
      pbr.z *= res.METALLIC_CHANNEL;
      pbr.w *= res.SPECULAR_INTENSITY_CHANNEL;
    #endif
    #if USE_METALLIC_ROUGHNESS_MAP
      vec4 metallicRoughness = texture(metallicRoughnessMap, PBR_UV);
      pbr.z *= metallicRoughness.METALLIC_CHANNEL;
      pbr.y *= metallicRoughness.ROUGHNESS_CHANNEL;
    #endif
    #if USE_OCCLUSION_MAP
      pbr.x *= texture(occlusionMap, PBR_UV).OCCLUSION_CHANNEL;
    #endif
    s.occlusion = pbr.x;
    s.roughness = pbr.y;
    s.specularIntensity = 0.5;
    s.metallic = pbr.z;

    s.emissive = emissive.rgb * emissiveScaleParam.xyz;
    #if USE_EMISSIVE_MAP
      s.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);
    #endif
  }

  CC_STANDARD_SURFACE_ENTRY()
}%
